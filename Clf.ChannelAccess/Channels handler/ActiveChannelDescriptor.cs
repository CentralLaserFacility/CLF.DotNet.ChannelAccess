//
// ActiveChannelDescriptor.cs
//

using System.Collections.Generic ;

using Clf.ChannelAccess.ExtensionMethods ;

using FluentAssertions ;

namespace Clf.ChannelAccess
{

  //
  // For any given 'ChannelWrapper', this holds a collection
  // of handlers that are to be invoked when an event arrives.
  // The underlying event will have been generated by the
  // WrappedChannel associated with the wrapper.
  //

  internal class ActiveChannelDescriptor 
  {

    private readonly ChannelWrapper ChannelWrapper ;

    private readonly System.Action<string> UnhandledExceptionHandler ;

    public ActiveChannelDescriptor(
      ChannelWrapper        channelWrapper, 
      System.Action<string> unhandledExceptionHandler
    ) {
      ChannelWrapper            = channelWrapper ;
      UnhandledExceptionHandler = unhandledExceptionHandler ;
    }

    // Could make these initially null and create them lazily ?
    // But generally every Channel will define at least one handler,
    // so there's no benefit to delaying the instantiation.

    private List<System.Action<bool,ChannelState>>      m_connectionStatusChangeHandlers = new() ;

    private List<System.Action<ValueInfo,ChannelState>> m_valueChangeHandlers            = new() ;

    public void AddHandlers (
      System.Action<bool,ChannelState>?      connectionStatusChangedHandler,
      System.Action<ValueInfo,ChannelState>? valueChangedHandler
    ) {
      if ( connectionStatusChangedHandler != null )
      {
        m_connectionStatusChangeHandlers.Add(connectionStatusChangedHandler) ;
      }
      if ( valueChangedHandler != null )
      {
        // Aha ! If we're not supporting StateChanged events, this is necessary !!
        ChannelWrapper.WrappedChannel.AsChannelBase().EnsureIsSubscribedToValueChangeCallbacks() ;
        m_valueChangeHandlers.Add(valueChangedHandler) ;
      }
    }

    private void RaiseExceptionMessage ( string eventType, System.Exception x )
    {
      UnhandledExceptionHandler?.Invoke(
        $"Exception was thrown handling '{eventType}' event on channel {ChannelWrapper.ChannelName} : {x.Message}"
      ) ;
    }

    public void InvokeConnectionStatusChangeHandlers ( bool isConnected, ChannelState state )
    {
      m_connectionStatusChangeHandlers.ForEach(
        handler => {
          try
          {
            handler(isConnected,state) ;
          }
          catch ( System.Exception x )
          {
            RaiseExceptionMessage("ConnectionStatusChanged",x) ;
          }
        }
      ) ;
    }

    public void InvokeValueChangeHandlers ( ValueInfo valueInfo, ChannelState state )
    {
      m_valueChangeHandlers.ForEach(
        handler => {
          try
          {
            handler(valueInfo,state) ;
          }
          catch ( System.Exception x )
          {
            RaiseExceptionMessage("ValueChanged",x) ;
          }
        }
      ) ;

    }

  }

}
